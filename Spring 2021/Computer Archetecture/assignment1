//programing assignment 1 by Daniel Black
// isu net id "dlblack"
//SELECTION SORTS A GIVEN ARRAY

//"FILL" CREATES THE ARRAY
//"SWAP" SWAPS THE VALUES OF 2 INDEXS THAT ARE STORED IN X2 AND X3
//"SMALL" STORES THE INDEX OF THE SMALLEST VALUE BETWEEN INDEX IN X4 AND INDEX IN X5 USING X6 AS A PIONTER TO CURRENT INDEX
//PROGRAM PRINTS THE FINAL ARRAY FROM INDEX 0 - 11 AFTER SORT IS COMPLETE

BL MAIN



FILL:

//loading numbers to an array in largest to smallest order by setting a register to a large number, storing that value in the stack,
//and then subtracting a value from the original register and storing that number
//increments X1 after each STUR to show size of array

ADDI X0, XZR, #147
STUR X0, [XZR, #0]
ADDI X1, X1, #1

SUBI X0, X0, #10
STUR X0, [XZR, #8]
ADDI X1, X1, #1

SUBI X0, X0, #11
STUR X0, [XZR, #16]
ADDI X1, X1, #1

SUBI X0, X0, #8
STUR X0, [XZR, #24]
ADDI X1, X1, #1

SUBI X0, X0, #3
STUR X0, [XZR, #32]
ADDI X1, X1, #1

SUBI X0, X0, #7
STUR X0, [XZR, #40]
ADDI X1, X1, #1

SUBI X0, X0, #5
STUR X0, [XZR, #48]
ADDI X1, X1, #1

SUBI X0, X0, #15
STUR X0, [XZR, #56]
ADDI X1, X1, #1

SUBI X0, X0, #17
STUR X0, [XZR, #64]
ADDI X1, X1, #1

SUBI X0, X0, #21
STUR X0, [XZR, #72]
ADDI X1, X1, #1

SUBI X0, X0, #30
STUR X0, [XZR, #80]
ADDI X1, X1, #1

SUBI X0, X0, #8
STUR X0, [XZR, #88]
ADDI X1, X1, #1

BL START





SWAP:
//swaps the indexes of X2 and X3

//SETS X2 AND X3 TO THE POINTER VALUE OF THEIR INDEX BY FUNCTIONALLY MULTIPLYING THEIR VALUE BY 8
LSL X2,X2,#3
LSL X3,X3,#3


//LOADS X9 WITH THE VALUE STORED IN THE ARRAY AT X2 AND X10 WITH WHAT'S AT X3
LDUR X9, [X2,#0]

LDUR X10, [X3,#0]


STUR X10,[X2, #0]
STUR X9,[X3, #0]

LDUR X9, [X2,#0]

LDUR X10, [X3,#0]


LSR X2,X2,#3
LSR X3,X3,#3


BL NEXT

SMALL:

//MOVES PIONTER TO NEXT INDEX
ADDI X6, X6,#1


//CHECKS IF X6 IS EQUAL TO X5.  IF SO THE SMALL LOOP ENDS AND X7 WILL HOLD THE INDEX OF THE SMALLEST VALUE
SUBS XZR,X5,X6
B.EQ SMALLI

//LOADS VALUES OF INDEX X6 AND X7 INTO X9 AND X10 FOR COMPARISION
LSL X6, X6, #3
LSL X7, X7, #3
LDUR X9, [X6, #0]
LDUR X10, [X7,#0]

//CHECKS IF VALUE AT X9 IS GREATER THAN VALUE AT X10.  IF GREATER THAN SKIP SETTING X7.  IF X10 IS GREATER THEN X7 IS GIVEN THE INDEX OF X6 WHICH IS NOW THE SMALLEST INDEX
SUBS XZR, X9,X10
B.GE SKIP
ADDI X7,X6,#0

SKIP:
LSR X6, X6, #3
LSR X7, X7, #3

//LOOPS SEARCH FOR SMALLEST INDEX IN ARRAY
BL SMALL


MAIN:
// INITIALIZES VALUES FOR THE ARRAY TO CHECK
BL FILL

//TOP OF SELECTION SORT LOOP
START:


//SMALL SETUP
//X4 IS FIRST INDEX TO CHECK STARTS AT 0 TO BEGIN WITH

//X5 IS LAST INDEX TO CHECK.  SET TO ARRAY SIZE
ADDI X5, X1, #0

//X6 IS POINTER OF CURRENT VALUE TO CHECK. SET TO X4 TO BEGIN WITH
ADDI X6, X4, #0

//X7 HOLDS SMALLEST VALUE INDEX. SET TO X4 TO BEGIN WITH
ADDI X7, X4, #0

//MOVES TO "SMALL" TO FIND SMALLEST INDEXT WITHIN BOUNDS
BL SMALL

SMALLI:

//SETS SWAP PERAMITERS WHERE X4 IS THE FIRST IN OF THE ARRAY CHECKED FOR THE SMALLEST VALUE AND X7 IS THE INDEX OF THE SMALLEST VALUE OF THE ARRAY
ADDI X2, X4, #0
ADDI X3, X7, #0
BL SWAP

NEXT:

//INCREMENTS X4 AS PREVIOUS INDEX HAS SOLVED FOR THE SMALLES VALUE FOR THAT POSISTION.
ADDI X4, X4, #1

//CHECKS IF THE ARRAY HAS BEEN TRAVERSED BY COMPARING THE INDEX OF X4 TO THE SIZE OF THE ARRAY.  MOVES TO "START" IF X4 IS STILL WITHIN BOUNDS
SUBS XZR,X4,X1
B.LT START

// PRINTS THE 12 ARRAY PLACES
LDUR X0, [XZR, #0]
PRNT X0

LDUR X0, [XZR, #8]
PRNT X0

LDUR X0, [XZR, #16]
PRNT X0

LDUR X0, [XZR, #24]
PRNT X0

LDUR X0, [XZR, #32]
PRNT X0

LDUR X0, [XZR, #40]
PRNT X0

LDUR X0, [XZR, #48]
PRNT X0

LDUR X0, [XZR, #56]
PRNT X0

LDUR X0, [XZR, #64]
PRNT X0

LDUR X0, [XZR, #72]
PRNT X0

LDUR X0, [XZR, #80]
PRNT X0

LDUR X0, [XZR, #88]
PRNT X0

end:
